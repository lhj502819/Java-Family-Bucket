# 代理模式​

## template包：代理模式的模板

## staticproxy包：静态代理
缺点：

1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。

2）代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为UserManager类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。
## dynamicproxy 动态代理
某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本需求如下： (1) 在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统； (2) 在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。 该软件公司开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。 试使用代理模式设计并实现该收费商务信息查询系统。
![Image](https://cdn.nlark.com/yuque/0/2020/png/1171730/1587980313152-7d4221b3-df84-498c-8930-43835f047cf6.png)

# UML图：
![Image](https://cdn.nlark.com/yuque/0/2020/png/1171730/1587980522239-e54f89fe-218a-4b66-9218-efc4a123da1a.png)

AccessValidatory用于验证用户身份

Logger用于日志记录

Searcher是抽象主题角色

RealSearcher充当真实主题角色

ProxySearcher充当代理主题角色

本实例是 保护代理 和 智能引用代理 的应用实例，在代理类ProxySearcher中实现对真实主题类的权限控制和引用计数，如果需要在访问真实主题时增加新的访问控制机制和新功能，只需增加一个新的代理类，再修改配置文件，在客户端代码中使用新增代理类即可，源代码无须修改，符合开闭原则。

#### 文档地址：https://www.yuque.com/lihongjian/codingrecord/gd8gkg#OEdWt